<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crystal Golden Tree</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Times New Roman', serif; }
        
        /* 纯黑背景，只保留极微弱的中心光，突出主体 */
        #canvas-container { 
            width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; 
            background: radial-gradient(circle at center, #111 0%, #000 70%);
        }
        
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 10; pointer-events: none;
            display: flex; flex-direction: column; 
            align-items: center; justify-content: flex-end; /* 标题放下面一点，不挡树头 */
            padding-bottom: 80px;
        }
        
        .ui-hidden { opacity: 0; pointer-events: none !important; }

        /* 极简标题 */
        h1 {
            color: #fff; font-size: 40px; margin: 0; font-weight: 100;
            letter-spacing: 12px;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
            font-family: 'Cinzel', serif;
            opacity: 0.8;
            text-transform: uppercase;
        }

        /* 按钮样式微调 */
        .upload-wrapper {
            position: absolute; top: 30px; left: 30px; pointer-events: auto; z-index: 20;
            transition: opacity 0.5s;
        }
        .upload-btn {
            background: rgba(0,0,0,0.5); border: 1px solid rgba(255, 215, 0, 0.3); 
            color: #d4af37; padding: 10px 20px; cursor: pointer; 
            letter-spacing: 2px; font-size: 10px; text-transform: uppercase;
            border-radius: 30px; /* 圆角更优雅 */
            backdrop-filter: blur(4px);
        }
        .upload-btn:hover { background: #d4af37; color: #000; }
        .hint-text { color: #666; font-size: 9px; margin-top: 8px; margin-left: 5px; }

        #file-input { display: none; }
        
        #loader {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 100;
            display: flex; align-items: center; justify-content: center;
            transition: opacity 0.5s;
        }
    </style>
    
    <style>@import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400&display=swap');</style>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
                "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm"
            }
        }
    </script>
</head>
<body>

    <div id="loader"><div style="color:#d4af37; font-size:12px; letter-spacing:4px;">LOADING</div></div>

    <div id="canvas-container"></div>

    <div class="upload-wrapper">
        <label class="upload-btn">
            + Add Photo
            <input type="file" id="file-input" multiple accept="image/*">
        </label>
        <div class="hint-text">Key 'H' to Hide | Hand Gestures Enabled</div>
    </div>

    <div id="ui-layer">
        <h1>Merry Christmas</h1>
    </div>

    <video id="webcam" autoplay playsinline style="display:none;"></video>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { FilesetResolver, HandLandmarker } from '@mediapipe/tasks-vision';

        // --- CONFIG ---
        // 核心配置：只用三种颜色，保证画面干净
        const CONFIG = {
            colors: {
                gold: 0xffcc33,     // 香槟金
                brightGold: 0xfffwd, // 高光金
                red: 0x880000,      // 深红
                white: 0xffffff
            },
            tree: {
                height: 35,
                radius: 12,
                particleCount: 1600
            }
        };

        const STATE = {
            mode: 'TREE', 
            focusTarget: null,
            hand: { detected: false, x: 0, y: 0 },
            rotationY: 0,
            time: 0
        };

        let scene, camera, renderer, composer, controls;
        let mainGroup; 
        let particleSystem = []; 
        let clock = new THREE.Clock();
        let handLandmarker, video;

        async function init() {
            initThree();
            setupLights();
            
            // 构建场景：分层构建，逻辑更清晰
            createSpiralTree();   // 主体：螺旋树
            createSpiralRibbon(); // 装饰：光带
            createGroundReflections(); // 底部：氛围
            createDefaultPhoto();
            
            setupPostProcessing();
            setupEvents();
            await initMediaPipe();
            
            document.getElementById('loader').style.opacity = 0;
            setTimeout(() => document.getElementById('loader').remove(), 500);
            
            animate();
        }

        function initThree() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.02); // 黑色雾气，增加深邃感

            camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 60); // 稍微拉远一点

            renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            // 关键修正：使用 Reinhard 而不是 ACES，避免金色变暗/变脏
            renderer.toneMapping = THREE.ReinhardToneMapping;
            renderer.toneMappingExposure = 2.0; 
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.autoRotate = false; // 我们手动控制旋转
            controls.enablePan = false;
            controls.maxDistance = 90;
            controls.minDistance = 20;

            mainGroup = new THREE.Group();
            scene.add(mainGroup);
        }

        function setupLights() {
            // 环境光弱一点，保持对比度
            scene.add(new THREE.AmbientLight(0xffffff, 0.2));

            // 树心的暖光
            const coreLight = new THREE.PointLight(CONFIG.colors.gold, 1.5, 40);
            coreLight.position.set(0, 5, 0);
            mainGroup.add(coreLight);

            // 顶部聚光灯，照亮树冠
            const topSpot = new THREE.SpotLight(0xffffff, 1000);
            topSpot.position.set(0, 50, 20);
            topSpot.angle = 0.5;
            topSpot.penumbra = 0.5;
            scene.add(topSpot);
        }

        function setupPostProcessing() {
            const renderScene = new RenderPass(scene, camera);
            
            // 辉光参数修正：radius小一点，strength大一点 -> 看起来像星星，而不是雾
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0.2; // 只有亮的东西发光
            bloomPass.strength = 0.8;  // 强度适中
            bloomPass.radius = 0.3;    // 半径小，锐利

            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);
        }

        // --- 核心：几何生成 ---

        function createSpiralTree() {
            // 使用几何体做粒子，而不是BufferGeometry，方便独立动画
            const geometrySmall = new THREE.SphereGeometry(0.15, 8, 8);
            const geometryBig = new THREE.OctahedronGeometry(0.3, 0); // 钻石形状
            
            // 材质：自发光很重要
            const goldMat = new THREE.MeshStandardMaterial({
                color: CONFIG.colors.gold,
                emissive: 0xffaa00,
                emissiveIntensity: 0.5,
                roughness: 0.2, metalness: 0.9
            });
            
            const redMat = new THREE.MeshStandardMaterial({
                color: CONFIG.colors.red,
                emissive: 0x330000, emissiveIntensity: 0.2,
                roughness: 0.1, metalness: 0.5
            });

            const count = CONFIG.tree.particleCount;
            
            for (let i = 0; i < count; i++) {
                // 算法：圆锥上的斐波那契螺旋
                const ratio = i / count; // 0 到 1 (底 到 顶)
                const y = (1 - ratio) * CONFIG.tree.height - (CONFIG.tree.height / 2);
                
                // 半径随高度变小
                const radius = ratio * CONFIG.tree.radius; 
                
                // 角度：黄金角，保证不重叠，分布均匀
                const angle = i * 2.39996; 
                
                // 基础位置
                const x = Math.cos(angle) * radius;
                const z = Math.sin(angle) * radius;

                // 随机选择形状和材质
                let mesh;
                let type = 'GOLD';
                
                if (Math.random() > 0.85) {
                    mesh = new THREE.Mesh(geometryBig, redMat);
                    type = 'RED';
                } else {
                    mesh = new THREE.Mesh(geometrySmall, goldMat);
                }

                // 添加一点随机偏移，看起来更自然，不要太死板
                const spread = 0.5;
                mesh.position.set(
                    x + (Math.random()-0.5)*spread, 
                    y + (Math.random()-0.5)*spread, 
                    z + (Math.random()-0.5)*spread
                );
                
                mesh.scale.setScalar(0.5 + Math.random());
                mesh.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, 0);

                mainGroup.add(mesh);
                particleSystem.push(new Particle(mesh, type, x, y, z));
            }

            // 树顶的大星星
            const starGeo = new THREE.OctahedronGeometry(1.5, 0);
            const starMat = new THREE.MeshStandardMaterial({
                color: 0xffffff, emissive: 0xffddaa, emissiveIntensity: 2.0
            });
            const star = new THREE.Mesh(starGeo, starMat);
            star.position.set(0, CONFIG.tree.height/2 + 0.5, 0);
            mainGroup.add(star);
            particleSystem.push(new Particle(star, 'STAR', 0, CONFIG.tree.height/2 + 0.5, 0));
        }

        function createSpiralRibbon() {
            // 创建一条明显的光带螺旋上升
            const points = [];
            const steps = 300;
            const h = CONFIG.tree.height;
            const r = CONFIG.tree.radius + 1; // 比树稍微宽一点
            
            const sphere = new THREE.SphereGeometry(0.12, 8, 8);
            const mat = new THREE.MeshBasicMaterial({ color: 0xffffff });

            for(let i=0; i<steps; i++) {
                const t = i/steps;
                const y = (1-t) * h - (h/2);
                const currentR = t * r;
                const angle = t * Math.PI * 12; // 绕6圈

                const x = Math.cos(angle) * currentR;
                const z = Math.sin(angle) * currentR;

                const mesh = new THREE.Mesh(sphere, mat);
                mesh.position.set(x,y,z);
                mainGroup.add(mesh);
                
                // 标记为 RIBBON
                particleSystem.push(new Particle(mesh, 'RIBBON', x, y, z));
            }
        }

        function createGroundReflections() {
            // 地面上的镜面反射微粒
            const geo = new THREE.PlaneGeometry(0.3, 0.3);
            const mat = new THREE.MeshBasicMaterial({ 
                color: CONFIG.colors.gold, transparent: true, opacity: 0.3, side: THREE.DoubleSide 
            });

            for(let i=0; i<100; i++) {
                const mesh = new THREE.Mesh(geo, mat);
                const r = Math.random() * 20;
                const a = Math.random() * Math.PI * 2;
                const x = Math.cos(a) * r;
                const z = Math.sin(a) * r;
                
                mesh.position.set(x, -CONFIG.tree.height/2 - 0.5, z);
                mesh.rotation.x = Math.PI / 2;
                mainGroup.add(mesh);
                // 静态装饰，不放入粒子系统
            }
        }

        // --- 逻辑 ---

        class Particle {
            constructor(mesh, type, targetX, targetY, targetZ) {
                this.mesh = mesh;
                this.type = type;
                
                // 目标形态：树
                this.treePos = new THREE.Vector3(targetX, targetY, targetZ);
                
                // 目标形态：散乱
                const burstR = 20 + Math.random() * 30;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                this.scatterPos = new THREE.Vector3(
                    burstR * Math.sin(phi) * Math.cos(theta),
                    burstR * Math.sin(phi) * Math.sin(theta),
                    burstR * Math.cos(phi)
                );

                this.baseScale = mesh.scale.x;
                this.phase = Math.random() * Math.PI * 2;
            }

            update(dt, time, mode, focusTarget) {
                let targetPos = this.treePos;
                let targetScale = this.baseScale;
                
                // 1. 位置逻辑
                if (mode === 'SCATTER') {
                    targetPos = this.scatterPos;
                    // 散开时旋转
                    this.mesh.rotation.x += dt;
                    this.mesh.rotation.y += dt;
                } else if (mode === 'FOCUS') {
                    if (this.mesh === focusTarget) {
                        // 聚焦：飞到相机前
                        const worldTarget = new THREE.Vector3(0, 0, 50); 
                        // 将世界坐标转为本地坐标（因为mesh在mainGroup里）
                        const invWorld = new THREE.Matrix4().copy(mainGroup.matrixWorld).invert();
                        targetPos = worldTarget.applyMatrix4(invWorld);
                        targetScale = 5.0; // 放大
                        this.mesh.lookAt(camera.position);
                    } else {
                        targetPos = this.scatterPos; // 其他闪开
                    }
                }

                // 平滑移动
                this.mesh.position.lerp(targetPos, 3.0 * dt);

                // 2. 闪烁逻辑 (Breathing Effect)
                if (this.type === 'GOLD' || this.type === 'RIBBON') {
                    // 利用正弦波制造呼吸感
                    const blink = Math.sin(time * 2 + this.phase); 
                    // 改变发光强度
                    if (this.mesh.material.emissiveIntensity !== undefined) {
                        const base = this.type === 'RIBBON' ? 0.8 : 0.5;
                        this.mesh.material.emissiveIntensity = base + blink * 0.3;
                    }
                    // 微调大小
                    if (mode === 'TREE') {
                        targetScale = this.baseScale * (1 + blink * 0.2);
                    }
                }

                this.mesh.scale.lerp(new THREE.Vector3(targetScale, targetScale, targetScale), 4.0 * dt);
            }
        }

        // --- 照片与交互 ---
        
        function createDefaultPhoto() {
            const canvas = document.createElement('canvas');
            canvas.width = 512; canvas.height = 512;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#000'; ctx.fillRect(0,0,512,512);
            ctx.strokeStyle = '#d4af37'; ctx.lineWidth = 15; ctx.strokeRect(20,20,472,472);
            ctx.fillStyle = '#d4af37'; ctx.font = '60px serif'; ctx.textAlign = 'center';
            ctx.fillText("JOY", 256, 260);
            
            const tex = new THREE.CanvasTexture(canvas);
            addPhoto(tex);
        }

        function addPhoto(texture) {
            texture.colorSpace = THREE.SRGBColorSpace;
            const geo = new THREE.PlaneGeometry(1.5, 1.5);
            const mat = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide });
            const mesh = new THREE.Mesh(geo, mat);
            
            // 给照片加个金框
            const borderGeo = new THREE.BoxGeometry(1.6, 1.6, 0.05);
            const borderMat = new THREE.MeshStandardMaterial({ color: CONFIG.colors.gold, metalness: 1 });
            const border = new THREE.Mesh(borderGeo, borderMat);
            border.position.z = -0.05;
            mesh.add(border);

            // 随机挂在树上
            const r = Math.random() * (CONFIG.tree.radius * 0.7);
            const angle = Math.random() * Math.PI * 2;
            const y = (Math.random() - 0.5) * CONFIG.tree.height * 0.6;
            
            const group = new THREE.Group();
            group.add(mesh);
            mainGroup.add(group);
            
            // 记录原始位置
            particleSystem.push(new Particle(group, 'PHOTO', Math.cos(angle)*r, y, Math.sin(angle)*r));
        }

        document.getElementById('file-input').addEventListener('change', (e) => {
            if(e.target.files.length) {
                Array.from(e.target.files).forEach(f => {
                    const reader = new FileReader();
                    reader.onload = (ev) => {
                        new THREE.TextureLoader().load(ev.target.result, addPhoto);
                    }
                    reader.readAsDataURL(f);
                });
            }
        });

        // --- 循环 ---

        function animate() {
            requestAnimationFrame(animate);
            
            const dt = clock.getDelta();
            STATE.time += dt;

            // 旋转逻辑：平滑而优雅
            if (STATE.mode === 'SCATTER' && STATE.hand.detected) {
                // 手势控制
                const targetRotY = STATE.hand.x * Math.PI;
                const targetRotX = STATE.hand.y * Math.PI * 0.5;
                mainGroup.rotation.y += (targetRotY - mainGroup.rotation.y) * 2 * dt;
                mainGroup.rotation.x += (targetRotX - mainGroup.rotation.x) * 2 * dt;
            } else {
                // 自动旋转
                mainGroup.rotation.y -= 0.15 * dt; // 逆时针慢转
                mainGroup.rotation.x = THREE.MathUtils.lerp(mainGroup.rotation.x, 0, 2*dt);
            }

            controls.update();

            // 更新所有粒子
            particleSystem.forEach(p => p.update(dt, STATE.time, STATE.mode, STATE.focusTarget));

            composer.render();
        }

        // --- MediaPipe (保持不变) ---
        async function initMediaPipe() {
            try {
                const vision = await FilesetResolver.forVisionTasks(
                    "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm"
                );
                handLandmarker = await HandLandmarker.createFromOptions(vision, {
                    baseOptions: {
                        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
                        delegate: "GPU"
                    },
                    runningMode: "VIDEO",
                    numHands: 1
                });
                video = document.getElementById('webcam');
                if (navigator.mediaDevices?.getUserMedia) {
                    const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                    video.srcObject = stream;
                    video.addEventListener("loadeddata", predictWebcam);
                }
            } catch(e) { console.log("Webcam error", e); }
        }

        let lastVideoTime = -1;
        async function predictWebcam() {
            if (video.currentTime !== lastVideoTime && handLandmarker) {
                lastVideoTime = video.currentTime;
                const result = handLandmarker.detectForVideo(video, performance.now());
                if (result.landmarks && result.landmarks.length > 0) {
                    STATE.hand.detected = true;
                    const lm = result.landmarks[0];
                    STATE.hand.x = (lm[9].x - 0.5) * 2;
                    STATE.hand.y = (lm[9].y - 0.5) * 2;
                    
                    const thumb = lm[4]; const index = lm[8];
                    const dist = Math.hypot(thumb.x-index.x, thumb.y-index.y);
                    
                    // 逻辑：捏合看照片，手张开是树，手握拳散开
                    if(dist < 0.05) {
                        if(STATE.mode !== 'FOCUS') {
                            STATE.mode = 'FOCUS';
                            const photos = particleSystem.filter(p => p.type === 'PHOTO');
                            if(photos.length) STATE.focusTarget = photos[Math.floor(Math.random()*photos.length)].mesh;
                        }
                    } else if (dist > 0.15) { // 稍微放宽一点判定
                         STATE.mode = 'TREE';
                    }
                } else {
                    STATE.hand.detected = false;
                }
            }
            requestAnimationFrame(predictWebcam);
        }

        // 键盘H隐藏UI
        window.addEventListener('keydown', e => {
            if(e.key.toLowerCase() === 'h') document.querySelector('.upload-wrapper').classList.toggle('ui-hidden');
        });

        init();
    </script>
</body>
</html>
